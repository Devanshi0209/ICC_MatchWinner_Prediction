# -*- coding: utf-8 -*-
"""23MSP3095_23MSP3078.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WnU11PTY8MCTOAky3xiarVuHydSTeeRO
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report

#loading the data
df_1975 = pd.read_csv('CRICKET WORLD CUP - 1975 .csv')
df_1979 = pd.read_csv('CRICKET WORLD CUP - 1979.csv')
df_1983 = pd.read_csv('CRICKET WORLD CUP - 1983.csv')
df_1987 = pd.read_csv('CRICKET WORLD CUP - 1987.csv')
df_1992 = pd.read_csv('CRICKET WORLD CUP - 1992.csv')
df_1996 = pd.read_csv('CRICKET WORLD CUP - 1996.csv')
df_1999 = pd.read_csv('CRICKET WORLD CUP - 1999.csv')
df_2003 = pd.read_csv('CRICKET WORLD CUP - 2003.csv')
df_2007 = pd.read_csv('CRICKET WORLD CUP - 2007.csv')
df_2011 = pd.read_csv('CRICKET WORLD CUP - 2011.csv')
df_2015 = pd.read_csv('CRICKET WORLD CUP - 2015.csv')
df_2019 = pd.read_csv('CRICKET WORLD CUP - 2019.csv')

#combining the data
df = pd.concat([df_1975,df_1979,df_1983,df_1987,df_1992,df_1996,df_1999,df_2003,df_2007,df_2011,df_2015,df_2019])
print(df.columns)
df.head(10)

#dropping useless columns
df = df.drop(['YEAR'], axis=1)
df = df.drop('WINNER', axis=1)
df = df.drop('WINNER ', axis=1)
df.head(7)

#dropping null rows
df= df.dropna()
#dropping rows with invalid runs NR and tie games
df = df[df['RUNS SCORED'] != 'NR']
df = df[df['RESULT'] != 'NR']
df = df[df['RESULT'] != 'TIE']
df = df[df['RESULT'] != 'TIED']
df.head(7)

#printing about dataset
df.info()
df.describe()
#converting runs scored to float
df['RUNS SCORED'] = pd.to_numeric(df['RUNS SCORED'], errors='coerce')

# check for outliers with boxplot
plt.boxplot(df['RUNS SCORED'])
plt.title('Boxplot for "RUNS SCORED" Column')
plt.ylabel('Runs Scored')
plt.show()

#remove the outliers with IQR method
# Calculate the IQR (Interquartile Range)
Q1 = df['RUNS SCORED'].quantile(0.25)
Q3 = df['RUNS SCORED'].quantile(0.75)
IQR = Q3 - Q1

# Define the lower and upper bounds for outliers
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter rows without outliers
df_no_outliers = df[(df['RUNS SCORED'] >= lower_bound) & (df['RUNS SCORED'] <= upper_bound)]

# Display the DataFrame without outliers
print("DataFrame without outliers:")
print(df_no_outliers)

print(df_no_outliers.VENUE.unique())

class Visualization:
  def __init__(self,xcolumn,ycolumn):
    self.xcol = xcolumn
    self.ycol = ycolumn

  def plotBar(self):
    team_runs = df_no_outliers.groupby(self.xcol)[self.ycol].sum().reset_index()
    # Plotting the bar chart
    plt.bar(team_runs[self.xcol], team_runs[self.ycol], color='skyblue')
    plt.xlabel('Team')
    plt.ylabel('Total Runs Scored')
    plt.title('Total Runs Scored by Each Team')
    plt.show()

  def plotScatter(self):
    plt.scatter(df[self.xcol], df[self.ycol], color='blue', alpha=0.7)
    plt.xlabel('Runs Scored')
    plt.ylabel('Wickets Lost')
    plt.title('Scatter Plot of Runs Scored vs. Wickets Lost')
    plt.grid(True)
    plt.show()

  def plotPie(self):
    result_counts = df[self.xcol].value_counts()
    # Plotting the pie chart
    plt.pie(result_counts, labels=result_counts.index, autopct='%1.1f%%', startangle=90, colors=['lightcoral', 'lightgreen'])
    plt.title('Venue Distribution')
    plt.show()

visobj1 = Visualization("TEAM","RUNS SCORED")
visobj1.plotBar()

visobj2 = Visualization("RUNS SCORED","WICKETS LOST")
visobj2.plotScatter()

visobj3 = Visualization("VENUE","")
visobj3.plotPie()

import sqlite3
try:
  sqliteconnection= sqlite3.connect('sample5.db')
  sqlite_create_table_query=''' CREATE TABLE MATCH (id INTEGER PRIMARY KEY,
  TEAM TEXT NOT NULL,
  AGAINST text NOT NULL,
  RUNS_SCORED INTEGER NOT NULL,
  WICKETS_LOST INTEGER NOT NULL,
  WICKETS_TAKEN INTEGER NOT NULL,
  RESULT TEXT NOT NULL,
  VENUE TEXT NOT NULL);'''
  cursor=sqliteconnection.cursor()
  print ("successfully connected")
  cursor.execute(sqlite_create_table_query)
  sqliteconnection.commit()
  print("sqlite table created")
  cursor.close()
except sqlite3.Error as error:
  print("Error while creating",error)
finally:
  if sqliteconnection:
    sqliteconnection.close()
    print("sqlite connection is closed")

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline

# Assuming 'df_no_outliers' is your DataFrame
df_no_outliers['RESULT'] = df_no_outliers['RESULT'].map({'WON': 1, 'LOST': 0})

# Features (X) and target variable (y)
X = df_no_outliers[['TEAM', 'AGAINST', 'VENUE']]
y = df_no_outliers['RESULT']

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=42)

# Preprocessing pipeline
preprocessor = ColumnTransformer(
    transformers=[
        ('cat', OneHotEncoder(drop='first'), ['TEAM', 'AGAINST', 'VENUE'])
    ],
    remainder='passthrough'
)

# Logistic Regression model
clf = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('classifier', LogisticRegression())
])

# Fit the model
clf.fit(X_train, y_train)

# Predictions on the test set
predictions = clf.predict(X_test)

from sklearn.metrics import accuracy_score
accuracy = accuracy_score(y_test, predictions)
print("Accuracy:", accuracy)
print("CLassification report")
print(classification_report(y_test,predictions))

#these values can be changed based on which countries are playing when we want to predict
new_data = pd.DataFrame({
    'TEAM': ['IND'],
    'AGAINST': ['AUS'],
    'VENUE': ['AHMEDABAD']
})
print(clf.predict(new_data)[0]) # 0 meaning india will lose and 1 meaning india will win

from sklearn.metrics import confusion_matrix
import seaborn as sns
cf = confusion_matrix(y_test,predictions)
plt.figure()
sns.heatmap(cf,annot=True)
plt.xlabel('Prediction')
plt.ylabel('Target')
plt.title('Confusion Matrix')